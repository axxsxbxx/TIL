## 1. 인터페이스

> 추상 클래스보다 추상성이 더욱 심화된 개념

- 멤버 변수는 상수형으로 선언되어야 함
- 메서드는 모두 추상 메서드로 선언되어야 함
- 인터페이스는 상수와 추상 메서드 외에 다른 멤버를 갖지 못하게 함으로써 추상 클래스보다 더욱 완벽한 추상화를 제공함
- 인터페이스를 통해 **다중상속과 유사한 기능** 구현 가능

#### [ 인터페이스의 정의 ]

```java
public interface 인터페이스명 [extends 부모인터페이스명, ...] {
    // 상수
    // 추상 메서드
}
```

- 상수 : `static과 final 예약어`를 이용해서 멤버 변수를 선언해야 함
- 인터페이스에 포함되는 메서드는 추상 메서드로 선언되므로, 메서드의 블록을 가지지 못함
- 인터페이스의 변수 선언에 사용된 static final이나 메서드 선언에 사용된 abstract는 생략 가능

#### [ 인터페이스의 활용 ]

> 인터페이스는 추상 클래스와 유사하기 때문에 직접 **객체화되지 못함**

인터페이스의 상속(`implements` 예약어 사용) → 자식 클래스 생성 → 자식 클래스의 객체 생성 → 프로그램 사용

```java
[modifiers] class 클래스명 [extends 부모 클래스][implements 인터페이스1, ...]{
    
}
```

- 인터페이스를 상속하는 클래스는 인터페이스에 정의된 추상 메서드들을 Overriding 해야 함
  - 블록을 추가하여 추상 메서드의 기능을 구현해야 함
  - 하나라도 Overriding 하지 않으면, 추상 메서드가 상속되어 해당 클래스는 abstract 예약어가 붙은 추상 클래스로 선언됨

#### [ 형변환 ]

- 클래스와 동일하게 묵시적 형변환과 명시적 형변환이 가능함
- 인터페이스는 부모 클래스와 동일한 지위를 가짐
- 인터페이스 유형의 객체 참조 변수는 인터페이스에 선언된 요소에만 접근 가능
- 인터페이스를 구현한 객체의 요소에 접근하는 것은 허용되지 않음



## 2. 패키지

>  자바의 클래스들을 분류하고, 관련된 클래스와 인터페이스를 하나의 폴더에 적절하게 배치할 때 관련된 클래스들이 묶여 있는 폴더

- 다른 기능을 구현한 같은 이름의 클래스를 사용할 때 **이름의 충돌을 피할 수 있음**
- **관리가 용이**하며, 클래스의 접근 권한을 패키지 단위로 제어할 수 있음
- API에 제공되는 많은 클래스들을 패키지화하여 제공함
- 사용자가 만든 클래스들을 패키지화해서 사용할 수도 있음

### 1) import 예약어

> API에 제공되는 패키지화된 클래스들을 사용하기 위해 사용함

- 별도의 패키지를 지정하지 않은 경우에는 디폴트 패키지가 됨
  - 디폴트 패키지의 클래스를 사용할 때는 import 문을 사용하지 않음
- 동일한 이름의 클래스는 여러 개 import 할 수 없음

#### [ 패키지 이름 지정 방법 ]

> 컴파일 시간의 효율성과 연관이 있음

- 패키지의 특정 클래스 이름 까지 포함된 완전한 이름을 사용하는 경우
  - 패키지 내의 한 클래스만 사용하는 경우
- 패키지 이름만을 사용하는 경우
  - 한 패키지 내에 여러 클래스가 사용되는 경우



## 2. 패키지

> 윈도우 탐색기에서 폴더 또는 디렉토리 개념과 같음

### 1) package 예약어

> 개발자가 작성한 클래스를 특정 패키지로 묶을 수 있음

- 클래스를 개발할 때, 관련된 클래스들을 그룹으로 묶어서 폴더 단위로 관리할 수 있음

```java
package 상위패키지명.패키지명;
package 패키지명;
```

- 패키지 선언 문장을 반드시 첫 번째 문장으로 기술해야 함



### 2) 커스텀 라이브러리

> API에서 제공하지 않거나, API를 응용해서 개발자가 직접 만든 클래스들을 라이브러리 형태로 만들어서 사용할 수 있음

- 비슷한 기능들을 간단하게 구현할 수 있으며, 다른 애플리케이션에서도 재사용이 가능함

