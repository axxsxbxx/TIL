#### [ 오류의 종류 ]

| 에러(Error)                                                  | 예외(Exception)                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 프로그램으로 처리할 수 없기 때문에 에러 발생 시 프로그램이 중단 됨 | - 프로그램 실행 중에 발생할 수 있는 가벼운 사건<br />- 프로그래머가 충분히 예측할 수 있는 사건<br />- 프로그램적으로 얼마든지 처리할 수 있는 오류 |



## 1. 예외

> 자바는 객체지향 언어이므로 예외도 객체로 처리함
>
> - 예외를 객체로 처리하기 위해 객체를 생성할 클래스가 필요함

- 발생 가능성이 있는 모든 예외 상황을 미리 예측하여 다양한 예외 클래스를 제공함

#### [ 예외가 발생하는 경우 ]

- 정수를 0으로 나누는 경우
- 배열의 인덱스가 음수 값을 가지는 경우
- 배열의 인덱스가 배열의 길이를 넘어서는 경우
- 부적절한 형변환이 발생하는 경우
- 입출력 시 인터럽트가 발생하는 경우
- 입출력을 위해 필요한 파일이 존재하지 않는 경우

#### [ 예외 처리 과정 ]

예외 발생 → JVM은 해당 예외 상황에 해당하는 예외 객체 생성 → 프로그램으로 예외 객체 throw → 프로그램은 JVM이 던진 예외 객체를 받아서 예외 처리 로직을 수행하고, 프로그램을 계속 진행함

##### 프로그램에 예외 처리 로직을 구현하지 않은 경우

- 기본 예외 처리 핸들러가 작동함

- 단순히 에러 메시지를 화면에 출력하고, 실행을 중지시킴

  

### 1) 예외 클래스

> 예외 객체를 생성하기 위한 다양한 예외 클래스가 존재함

- 모든 예외는 java.lang.Trowable 클래스의 자식 클래스인 java.lang.Exception 클래스의 자식 클래스로 만들어짐
- 이름만으로 어떤 의미의 예외인지 알 수 있도록 작성됨

#### [ 예외 클래스의 종류 ]

- ArithmeticException : 정수를 0으로 나누는 경우 산술 연산 오류
- IndexOutOfBoundsException : 배열의 인덱스가 배열의 길이를 넘어서면 발생하는 오류
- IllegalArgumentException : 메서드의 매개변수 유형을 잘못 사용하면 발생하는 오류
- IOException : 입출력 시에 지정한 파일이 시스템에 존재하지 않으면 발생하는 오류



## 2. 예외 처리

> 자바 언어를 더욱 강하게 만드는 요인

#### [ 자바의 예외 처리 방법 ]

##### < 예외가 발생하는 메서드 내에서 직접 처리하는 방식 >

### 1) try-catch 구문

```java
try{
    예외 발생 가능이 있는 소스코드;
}catch(예외 타입 매개변수명){
    예외타입의 예외가 발생할 경우 수행될 소스코드;
}
```

- try 블록
  - 예외가 발생할 수 있는 소스코드들을 작성함
  - 최소한 하나의 catch 블록이 있어야 함
- catch 블록
  - try 블록 다음에 위치함
  - 매개변수는 예외 객체가 발생했을 때 참조하는 변수명으로, 반드시 java.lang.Trowable 클래스의 하위 클래스 타입으로 선언되어야 함

- 예외 처리 과정
  - 지정한 타입의 예외 객체 발생 → try 블록의 나머지 문장들은 수행되지 않음 → JVM은 발생한 예외 객체를 발생시킴 → 발생한 예외 객체 타입에 해당하는 catch 블록을 수행함



### 2) 다중 catch 블록

> 프로그램에서 발생하는 예외에 따라서 적절하게 예외 처리를 분기시켜야 함
>
> 다중 catch 블록을 사용하여 여러 개의 예외를 처리함

```java
try{
    예외 발생 가능이 있는 소스코드;
}catch(예외 타입1 매개변수명){
    예외타입1의 예외가 발생할 경우 수행될 소스코드;
}catch(예외 타입n 매개변수명){
    예외타입n의 예외가 발생할 경우 수행될 소스코드;
}
```

- try 블록 내에서 발생되는 모든 예외에 대해서 적절한 예외 처리 로직이 수행되도록 함



### 3) 상속을 이용한 예외 처리

> 자바에서 지원하는 모든 예외 클래스는 Exception 클래스의 자식 클래스로 존재함

- Exception 객체는 형변환에 의해 Exception 타입의 변수로 할당됨



### 4) finally 블록

```java
try{
    예외 발생 가능이 있는 소스코드;
}catch(예외 타입 매개변수명){
    예외타입의 예외가 발생할 경우 수행될 소스코드;
}finally{
    예외 발생 여부와 무관하게 무조건 수행될 코드;
}
```

- finally 블록은 try 블록과 함께 사용될 수 있음
- 필수적으로 사용하는 블록은 아니므로 프로그래머의 편의에 따라 사용함
- finally 블록의 내용은 예외 발생 유무나 예외 catch 유무와 상관 없이 무조건 수행됨
- 반드시 수행되어야 할 로직이 있는 경우에 사용함



##### < 해당 메서드를 호출한 곳으로 예외 처리를 넘기는 방식 >

### 5) throws 예약어

> 예외가 발생한 메서드를 호출한 지점으로 예외를 전달하여 처리하는 방법

```java
[modifiers] returnType 메서드명([argType argName,...])[throws exceptionName1, exceptionName2, ...]
```

- throws 예약어와 현재 발생한 예외 객체의 클래스 이름을 나열함
- 발생된 예외 객체가 RuntimeException의 자식 클래스인 경우, 명시적으로 throws 문을 사용하지 않아도 자동으로 throws 됨



## 3. 사용자 정의 예외

> API에서 제공하지 않을 경우 개발자가 직접 예외 클래스를 정의해서 사용함

- 모든 예외 클래스의 최상위 클래스인 java.lang.Exception 클래스를 상속받아 정의함

```java
class 예외 클래스명 extends Exception
```

- 사용자 정의 예외 클래스 형태의 예외 객체는 JVM에 의해 자동으로 발생되지 않음
  - 사용자 정의 예외 클래스 객체를 발생시켜서 처리하려면 반드시 throw 예약어를 이용해야 함

```java
throw new 예외 클래스명();
```

